/*!

\page overview__page Overview

\tableofcontents

\section init_overview Configuration, Initialization, and Shutdown

There are two stages in the setup of the JasPer library at run time:

  1. configuration; and
  2. initialization.

The configuration stage initializes the current configuration settings
for the library.
The configuration settings are initialized to their default values
using the `jas_conf_clear()` function
(where these default values are fixed at the time that the library is built).
The initialization stage initializes the library using the current
configuration settings.
The `jas_initialize()` function performs initialization (not configuration).
The library must be both configured and initialized (in that order)
before most code in the library can be used.
For backward compatibility with older versions of the
library, the `jas_init()` function performs both configuration and initialization
of the library.
(The `jas_init()` function internally calls `jas_conf_clear()` to initialize the
configuration settings with their default values before proceeding to
initialize the library.)
The library is cleaned up (i.e., shutdown) by invoking the `jas_cleanup()`
function.
The library cannot be re-initialized.
That is, calling `jas_init()` or `jas_initialize()` without an intervening
call to `jas_cleanup()` is not allowed.

All configuration, initialization, and cleanup of the library must be
performed on the same thread.  Otherwise, data races and other synchronization
problems will result.

No code in the library can be invoked prior to initialization of the
library (via `jas_init()` or `jas_initialize()`), with the exception
of the functions identified below.

Only the following functions may be called before the JasPer library is
configured (via `jas_conf_clear()`):

  - `jas_std_allocator_init()`
  - `jas_get_image_format_table()`
  - `jas_get_total_mem_size()`

The following functions may be called after the JasPer library is
configured (via `jas_conf_clear()`) but before it is initialized
(via `jas_init()` or `jas_initialize()`):

- the \c jas_conf_* family of functions, including functions such as:

  - `jas_conf_clear()`
  - `jas_conf_set_allocator()`
  - `jas_conf_set_allocator_wrapper()`
  - `jas_conf_set_debug_level()`
  - `jas_conf_set_max_mem()`
  - `jas_conf_set_dec_default_max_samples()`
  - `jas_conf_set_vlogmsgf()`
  - `jas_conf_set_image_format_table()`

\subsection init__state Library State

The JasPer library has the notion of a context.
A context is used to store certain state used by the library.
There can be multiple contexts in use at any given time.
From the library user's point of view, a context is specified using an opaque
handle.
The type of this handle is `jas_context_t`.
A handle with the special value of 0 does not correspond to a valid context.
It is analogous to a null pointer.

The JasPer library allows the current context to be set independently
for each thread.
That is, the current context is a per-thread setting.
When the library is initialized, a single context is automatically
created, which is referred to as the default context.
If the current context for a thread is set to the special value of 0,
the thread's current context becomes the default context.
A given context cannot be shared by more than one thread, as this would
lead to data races and other synchronization problems.
For this reason, of the threads that are using the JasPer library,
at most one thread may use the default context.
In an application that has multiple threads using the JasPer library,
it is recommended that no thread use the default context
(i.e., each thread should create and use its own context).
If only one thread needs to use the JasPer library (such as in the case
of a single-threaded application), that thread can simply use the
default context, eliminating the need to create additional contexts.

The JasPer library has two types of state:

  1. Global state.
     That is, state that is library wide.
  2. Per-context state.
     That is, state that only applies to a particular context.

Most state maintained by the library is in the form of per-context state.
This is motivated by the desire to minimize the sharing of state between
threads, which would require locking/synchronization.
The global state for the library includes:

  - the memory allocator to be used by the library
  - the maximum amount of memory that the library is permitted to use

The per-context state includes:

  - the debug level
  - the vlogmsgf function to be used for logging error/warning/informational
    messages
  - the image format table
  - the maximum number of samples in an image that a decoder is allowed to
    process

\subsection init__contexts Contexts

Contexts can be created and destroyed with the following functions:

  - `jas_context_create()`
  - `jas_context_destroy()`

The current context for the calling thread can be set/queried with the
following functions:

  - `jas_get_context()`
  - `jas_set_context()`

The various per-context settings can be set/queried with the following
functions:

  - `jas_context_set_debug_level()`
  - `jas_context_get_debug_level()`
  - `jas_context_set_dec_default_max_samples()`
  - `jas_context_get_dec_default_max_samples()`
  - `jas_context_set_vlogmsgf()`
  - `jas_context_get_vlogmsgf()`

\subsection init_setup_example_1 Example of Code for Library Setup

Setup of the library would typically be performed using code resembling
the following:

~~~~~~~~~~
/*
Configure the library using the default configuration settings.
*/
jas_conf_clear();

/*
Change any configuration parameters for which defaults are not suitable
by using the jas_conf_* family of functions.
An example of this type of code follows.
*/

static jas_std_allocator_t allocator;
jas_std_allocator_init(&allocator);
jas_conf_set_allocator(JAS_CAST(std_allocator_t *, &allocator));
jas_conf_set_max_mem(10000000);

/*
Initialize the JasPer library.
*/
if (jas_initialize()) {
	/* Handle the initialization error. */
}

/*
Use the library.
In the case that the library is only used in a single thread, there
is no need to explicitly create any contexts, as the default context can
safely be used.
*/

/* Clean up the library. */
jas_cleanup();
~~~~~~~~~~

In the case of an application in which the JasPer library is used in more than
one thread, each thread would typically establish its own context before
starting to use the library.
For each thread, the code for this might resemble something like the following:

~~~~~~~~~~
/* Create a new context. */
jas_context_t context;
if (!(context = jas_create_context())) {
	/* Handle the error. */
}
/* Set the context for the calling thread to this new context. */
jas_set_context(context);
~~~~~~~~~~

The cleanup of the context might resemble like the following:

~~~~~~~~~~
/* Stop using the context before it is destroyed. */
jas_set_context(0);
/* Destroy the context. */
jas_context_destroy(context);
~~~~~~~~~~

\subsection init_setup_example_2 Example of Code for Library Setup (jas_init)

Alternatively, the setup of the library can be performed using code resembling
the following, if the library configuration parameters do not need to be
changed from their defaults:

~~~~~~~~~~
if (jas_init()) {
	/* handle initialization error */
}

/* Use the library. */

/* Clean up the library. */
jas_cleanup();
~~~~~~~~~~

Contexts can also be created and used when the library is initialized
with `jas_init()` (just like in the case of `jas_initialize()`).

\subsection init_setup_example_3 Additional Examples of Library Setup

Some additional examples of using the `jas_conf_clear()`, `jas_initialize()`,
and `jas_init()` functions can be found in the source code for the application
programs `jasper`, `imginfo`, and `imgcmp`.
Moreover, the application program `multithread` is an example of a
program that uses the JasPer library in multiple threads.

\subsection init_allocators Memory Allocators and the Allocator Wrapper

The library provides a simple interface for memory allocators.
This is provided through the `jas_allocator_t` type.
An allocator object resides in memory managed by the library user.
If the library user invokes `jas_cleanup()` via `atexit()`, then
the allocator should obviously not be allocated on the stack.
(The `jas_cleanup()` function will use the allocator in order
to free memory previously allocated by the library.)

The `jas_std_allocator_init()` function provides a way to create
an allocator that uses `malloc()` and related functions from the
C standard library.

Normally, the JasPer library does not directly use the allocator
provided by the library user.  It instead uses this allocator
indirectly through a wrapper.
The allocator wrapper is a pseudo-allocator.  That is, it
does not actually allocate memory directly but rather delegates
the memory allocation operations to another allocator (namely,
the one specified by the library user).
The allocator wrapper tracks the amount of memory used by the
allocator to which it delegates.
This eliminates the need for the library user's allocator to track
this information itself.

As long as the allocator wrapper functionality is enabled, the
JasPer library will track how much memory is being used by
the allocator in order to allow a limit to be imposed on
memory usage.
The allocator wrapper composes with the allocator selected by
the library user, as explained above.
So, this memory limiting functionality is available even when the
library user provides a custom allocator that does not itself
track memory usage.

Although `jas_malloc()`, `jas_realloc()`, `jas_free()` and other related
functions internally use the allocator provided
by the library user for all memory allocations, this does not imply that
pointers returned by `jas_malloc()` (and related functions) can be used
with the library user's allocator directly.

An allocator provides functions with the following signatures
and semantics:

  - `void (*cleanup)(jas_allocator_t *allocator);`

    This function performs a clean-up operation, which cleans up the
    allocator when it is no longer needed.
    This operation should free any resources associated with the allocator.
    The allocator cannot be used after the clean-up operation is performed.
    This function pointer may be null, in which case the clean-up operation
    is treated as a no-op.

  - `void *(*alloc)(jas_allocator_t *allocator, size_t size);`

    This function performs a memory-allocation operation, and has
    behavior similar to `malloc()`.

  - `void (*free)(jas_allocator_t *allocator, void *pointer)`;

    This function performs a memory-deallocation operation, and has
    behavior similar to `free()`.

  - `void *(*realloc)(jas_allocator_t *allocator, void *pointer,
    size_t new_size);`

    This function performs a memory-reallocation operation, and has
    behavior similar to `realloc()`.

\subsection Logging

All error, warning, informational, and debugging messages
are normally generated via the logging interface provided by the library.
The library user can specify a special function used to generate
formatted logging messages.
The library user can therefore control where messages are directed.
The function has the following signature:

  - `int (*vlogprintf)(jas_logtype_t type, const char *format, va_list ap);`

    The function formats and outputs a log message.
    The interface of this function is somewhat similar to vprintf.
    In addition to a format string and items used for formatting, the
    function also takes a specification of the type of message being
    generated (e.g., error, warning, etc.).

This function is used in order to implement functions such as:

  - `jas_vlogmsgf()`
  - `jas_logprintf()`
  - `jas_logerrorf()`
  - `jas_logwarnf()`
  - `jas_loginfof()`
  - `jas_logdebugf()`


\section overview_streams I/O Streams

The library provides a type for representing a stream of characters
for input/output.
Such a stream is represented by the type `jas_stream_t`.
Streams (in the JasPer library) are similar to I/O streams in the C standard
library but have a few additional functionalities.
In particular, with JasPer I/O streams, it is possible to:

  - set a limit on the number of characters that can be read from or
    written to a stream;
  - put back more than one character read from a stream;
  - query the number of characters that have been read from or written to
    a stream; and
  - associate a stream with one of several different types of underlying
    data sources/sinks (including buffers in memory and temporary files).

The possible underlying sources/sinks for a stream include:

  - a stdio stream (i.e., FILE)
  - a file descriptor
  - a memory buffer
  - a temporary file

The following functions are used for opening/closing streams:

  - `jas_stream_fopen()`
  - `jas_stream_memopen2()`
  - `jas_stream_fdopen()`
  - `jas_stream_freopen()`
  - `jas_stream_tmpfile()`
  - `jas_stream_close()`


The following functions are used for reading/writing streams:

  - `jas_stream_read()`
  - `jas_stream_write()`
  - `jas_stream_peek()`
  - `jas_stream_printf()`
  - `jas_stream_puts()`
  - `jas_stream_gets()`
  - `jas_stream_ungetc()`
  - `jas_stream_getc()`
  - `jas_stream_putc()`
  - `jas_stream_peekc()`
  - `jas_stream_gobble()`
  - `jas_stream_pad()`

The following functions are used for getting/setting the position within a
stream:

  - `jas_stream_isseekable()`
  - `jas_stream_seek()`
  - `jas_stream_tell()`
  - `jas_stream_rewind()`

Numerous other functions for streams are also provided, including:

  - `jas_stream_flush()`
  - `jas_stream_copy()`
  - `jas_stream_display()`
  - `jas_stream_length()`
  - `jas_stream_eof()`
  - `jas_stream_error()`
  - `jas_stream_clearerr()`
  - `jas_stream_setrwlimit()`
  - `jas_stream_setwrcount()`
  - `jas_stream_getrwlimit()`
  - `jas_stream_getrwcount()`

\section overview_images Images

An image is represented by the type `jas_image_t`.
An image component is represented by the type `jas_image_cmpt_t`.

image creation/destruction:

  - `jas_image_create()`
  - `jas_image_create0()`
  - `jas_image_copy()`
  - `jas_image_destroy()`

image encoding/decoding:

  - `jas_image_decode()`
  - `jas_image_encode()`

other
  - `jas_image_rawsize()`

  - `jas_image_ishomosamp()`
  - `jas_image_cmprof()`
  - `jas_image_sampcmpt()`
  - `jas_image_writecmpt2()`
  - `jas_image_readcmpt2()`
  - `jas_image_chclrspc()`
  - `jas_image_dump()`

Image Component

  - `jas_image_cmptwidth()`
  - `jas_image_cmptheight()`
  - `jas_image_cmptsgnd()`
  - `jas_image_cmptprec()`
  - `jas_image_cmpthstep()`
  - `jas_image_cmptvstep()`
  - `jas_image_cmpttlx()`
  - `jas_image_cmpttly()`
  - `jas_image_cmptbrx()`
  - `jas_image_cmptbry()`

  - `jas_image_cmpt_domains_same()`

  - `jas_image_readcmpt()`
  - `jas_image_writecmpt()`
  - `jas_image_delcmpt()`
  - `jas_image_addcmpt()`
  - `jas_image_copycmpt()`

  - `JAS_IMAGE_CDT_GETSGND()`
  - `JAS_IMAGE_CDT_SETSGND()`
  - `JAS_IMAGE_CDT_GETPREC()`
  - `JAS_IMAGE_CDT_SETPREC()`
  - `jas_image_cmptdtype()`
  - `jas_image_depalettize()`
  - `jas_image_readcmptsample()`
  - `jas_image_writecmptsample()`
  - `jas_image_getcmptbytype()`

image format table
  - `jas_image_clearfmts()`
  - `jas_image_addfmt()`
  - `jas_image_lookupfmtbyid()`
  - `jas_image_lookupfmtbyname()`
  - `jas_image_fmtfromname()`
  - `jas_image_getfmt()`
  - `jas_image_strtofmt()`
  - `jas_image_fmttostr()`

\section overview_cm Color Management

color management profile

  - `jas_cmxform_create()`
  - `jas_cmxform_destroy()`
  - `jas_cmxform_apply()`
  - `jas_cmprof_createfromclrspc()`
  - `jas_cmprof_destroy()`
  - `jas_clrspc_numchans()`
  - `jas_cmprof_clrspc()`
  - `jas_cmprof_copy()`

color space

  - `jas_clrspc_create()`
  - `jas_clrspc_fam()`
  - `jas_clrspc_mbr()`
  - `jas_clrspc_isgeneric()`
  - `jas_clrspc_isunknown()`

\section overview_icc ICC Profiles

  - `jas_iccprof_load()`
  - `jas_iccprof_save()`
  - `jas_iccprof_destroy()`
  - `jas_iccprof_getattr()`
  - `jas_iccprof_setattr()`
  - `jas_iccprof_dump()`
  - `jas_iccprof_copy()`
  - `jas_iccprof_gethdr()`
  - `jas_iccprof_sethdr()`

  - `jas_iccattrval_destroy()`
  - `jas_iccattrval_dump()`
  - `jas_iccattrval_allowmodify()`
  - `jas_iccattrval_clone()`
  - `jas_iccattrval_create()`

  - `jas_iccattrtab_dump()`

  - `jas_iccprof_createfrombuf()`
  - `jas_iccprof_createfromclrspc()`

\section logging Logging

The library provides an interface for generating log messages.
Such messages are used to convey errors, warnings, and other information.
Each log message has a type.
The type of the log message is represented by the type `jas_logtype_t`.
This type has two components:

  - a class (e.g., error, warning, informational, debugging)
  - a priority (which is typically only used for debugging messages)

The class and priority of a log message can be obtained from its type
by using the functions:

  - `jas_logtype_get_class()`
  - `jas_logtype_get_priority()`

A log type can be initialized via the function:

  - `jas_logtype_init()`

Most error/warning and other messages generated by the JasPer library
(including its codecs) use the logging interface.
In particular, the following functions are used for logging:

  - `jas_vlogmsgf()`
  - `jas_logprintf()`
  - `jas_logerrorf()`
  - `jas_logwarnf()`
  - `jas_loginfof()`
  - `jas_logdebugf()`

All of these functions are ultimately routed through the
vlogmsgf function provided by the library user.
The default behavior of this function is to write messages to the
standard error stream.

*/
